"""
Runtime Security Monitoring Test Script

This script demonstrates the process execution and network connection monitoring
capabilities of Cylestio Monitor. It will:

1. Trigger a potentially suspicious process execution
2. Trigger a potentially suspicious network connection
3. Test connection to our own telemetry endpoint (which should be ignored)
4. Show the security alerts generated by both monitors
"""

import os
import socket
import subprocess
import time
import json
from pathlib import Path
import urllib.parse

import cylestio_monitor

# Create output directory for logs
output_dir = Path("./output")
output_dir.mkdir(exist_ok=True)
log_file = output_dir / "security_test.json"

# Custom telemetry endpoint for demonstration
custom_telemetry = "http://monitor.example.com:8080"

# Start monitoring with security features enabled
cylestio_monitor.start_monitoring(
    agent_id="runtime-security-test",
    config={
        "events_output_file": str(log_file),
        "debug_mode": True,
        "enable_rce_detection": True,
        "enable_network_detection": True,
        "security_sensitivity": "medium",
        "telemetry_endpoint": custom_telemetry
    }
)

print(f"üîç Monitoring started. Logs will be written to {log_file}")
print(f"üîå Using telemetry endpoint: {custom_telemetry}")

# Wait for monitoring to initialize
time.sleep(1)

# === PROCESS MONITORING TEST ===

print("\nüîç Testing process execution monitoring...")
try:
    # Execute a potentially suspicious command (cat /etc/passwd)
    # This would trigger security alerts in a real scenario
    print("  ‚Üí Executing potentially suspicious process")
    result = subprocess.run(
        ["cat", "/etc/passwd"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        check=False
    )
    print(f"  ‚úì Process executed successfully")
except Exception as e:
    print(f"  ‚úó Process execution failed: {e}")

# === NETWORK MONITORING TEST ===

print("\nüîç Testing network connection monitoring...")
try:
    # Try to connect to a potentially suspicious port (4444 - common C2 port)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1)
    
    print("  ‚Üí Attempting connection to potentially suspicious port")
    try:
        # This will likely fail to connect but will trigger the monitor
        s.connect(("localhost", 4444))
        print("  ‚úì Connected (unexpected)")
    except (ConnectionRefusedError, socket.timeout):
        print("  ‚úì Connection failed (expected)")
    finally:
        s.close()
except Exception as e:
    print(f"  ‚úó Network test failed: {e}")
    
# === TELEMETRY ENDPOINT FILTERING TEST ===

print("\nüîç Testing telemetry endpoint filtering...")
try:
    # Connect to our own telemetry endpoint (this should be ignored by monitoring)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1)
    
    # Parse the telemetry endpoint to get host and port
    parsed = urllib.parse.urlparse(custom_telemetry)
    host = parsed.hostname
    port = parsed.port or (443 if parsed.scheme == "https" else 80)
    
    print(f"  ‚Üí Attempting connection to our telemetry endpoint: {host}:{port}")
    try:
        # This will fail to connect since it's a fake endpoint, but that's expected
        s.connect((host, port))
        print("  ‚úì Connected (unexpected)")
    except (ConnectionRefusedError, socket.timeout):
        print("  ‚úì Connection failed (expected for test endpoint)")
    finally:
        s.close()
except Exception as e:
    print(f"  ‚úó Telemetry endpoint test failed: {e}")

# Wait for events to be recorded
time.sleep(2)

# === ANALYZE RESULTS ===

print("\nüîç Analyzing security logs...")

# Function to parse and display security events
def display_security_events(log_file):
    if not log_file.exists():
        print(f"  ‚úó Log file not found: {log_file}")
        return
    
    events = []
    with open(log_file, "r") as f:
        for line in f:
            try:
                event = json.loads(line.strip())
                events.append(event)
            except json.JSONDecodeError:
                pass
    
    process_events = [e for e in events if e.get("name") == "process.exec"]
    network_events = [e for e in events if e.get("name") == "net.conn_open"]
    alert_events = [e for e in events if e.get("name") == "security.alert"]
    
    print(f"  ‚Ä¢ Found {len(events)} total events")
    print(f"  ‚Ä¢ Process execution events: {len(process_events)}")
    print(f"  ‚Ä¢ Network connection events: {len(network_events)}")
    print(f"  ‚Ä¢ Security alerts: {len(alert_events)}")
    
    # Check if we have any connections to our telemetry endpoint
    telemetry_events = []
    for event in network_events:
        attrs = event.get("attributes", {})
        if attrs.get("net.dst.ip") == host and attrs.get("net.dst.port") == port:
            telemetry_events.append(event)
    
    if telemetry_events:
        print(f"  ‚úó Found {len(telemetry_events)} events for our telemetry endpoint (should be 0)")
    else:
        print(f"  ‚úì No events for our telemetry endpoint (correct behavior)")
    
    if alert_events:
        print("\nüö® Security Alerts:")
        for i, alert in enumerate(alert_events, 1):
            attrs = alert.get("attributes", {})
            alert_type = attrs.get("alert.type", "Unknown")
            severity = attrs.get("alert.severity", "unknown")
            evidence = attrs.get("alert.evidence", "No evidence provided")
            
            print(f"  Alert #{i}: {alert_type} (Severity: {severity})")
            print(f"  Evidence: {evidence}")
            print()

# Display events from the log file
display_security_events(log_file)

# Stop monitoring
cylestio_monitor.stop_monitoring()
print("\n‚úì Test completed and monitoring stopped.") 
"""
Tests for validating OpenTelemetry schema compliance.

These tests verify that events generated by the monitoring system
conform to the OpenTelemetry schema requirements.
"""

import pytest
from datetime import datetime
import uuid
import re

from cylestio_monitor.events.schema import StandardizedEvent
from cylestio_monitor.events.processing.logger import log_event


def test_event_structure_conversion():
    """Test that legacy event structure is properly converted to OTel format."""
    # Create event with legacy structure
    legacy_event = {
        "timestamp": datetime.now().isoformat(),
        "level": "INFO",
        "agent_id": "test-agent",
        "event_type": "LLM_call_start",
        "channel": "LLM",
        "data": {
            "prompt": "Hello, world!",
            "model": "claude-3-haiku-20240307",
        }
    }

    # Convert to StandardizedEvent
    event = StandardizedEvent.from_dict(legacy_event)
    
    # Convert back to dict to check structure
    result = event.to_dict()
    
    # Check that it follows OpenTelemetry format
    assert "name" in result
    assert "attributes" in result
    assert "event_type" not in result
    assert result["name"] == "LLM_call_start"


def test_attribute_naming_conventions():
    """Test that attributes follow OpenTelemetry naming conventions."""
    # Create event directly with OTel structure
    attributes = {
        "llm.model": "claude-3-haiku-20240307",
        "llm.request.type": "completion",
        "llm.request.prompt": "Hello, world!",
    }
    
    event = StandardizedEvent(
        timestamp=datetime.now(),
        level="INFO",
        agent_id="test-agent",
        name="llm.request",
        attributes=attributes
    )
    
    # Check that attributes follow OTel conventions
    result = event.to_dict()
    
    # All attribute keys should follow the namespace.property pattern
    for key in result["attributes"].keys():
        if "." not in key and key not in ["channel", "direction"]:  # Some legacy fields might not have namespace
            pytest.fail(f"Attribute key '{key}' doesn't follow namespace.property pattern")


def test_trace_context_fields():
    """Test that trace context fields are correctly formatted."""
    # Generate valid trace and span IDs
    trace_id = uuid.uuid4().hex[:32]
    span_id = uuid.uuid4().hex[:16]
    parent_span_id = uuid.uuid4().hex[:16]
    
    event = StandardizedEvent(
        timestamp=datetime.now(),
        level="INFO",
        agent_id="test-agent",
        name="llm.request",
        trace_id=trace_id,
        span_id=span_id,
        parent_span_id=parent_span_id,
        attributes={"llm.model": "test-model"}
    )
    
    result = event.to_dict()
    
    # Verify trace context fields are present and formatted correctly
    assert "trace_id" in result
    assert "span_id" in result
    assert "parent_span_id" in result
    
    # Trace ID should be 32 hex characters (16 bytes)
    assert re.match(r"^[0-9a-f]{32}$", result["trace_id"])
    
    # Span IDs should be 16 hex characters (8 bytes)
    assert re.match(r"^[0-9a-f]{16}$", result["span_id"])
    assert re.match(r"^[0-9a-f]{16}$", result["parent_span_id"])


def test_event_category_determination():
    """Test that event categories are correctly determined from names."""
    test_cases = [
        ("llm.request", "llm"),
        ("llm.response", "llm"),
        ("tool.execution", "tool"),
        ("chain.start", "framework"),
        ("graph.node.start", "framework"),
        ("retrieval.query", "retrieval"),
        ("framework.initialization", "system"),
        ("user.message", "user_interaction"),
        ("unknown", "system")  # Default category
    ]
    
    for name, expected_category in test_cases:
        event = StandardizedEvent(
            timestamp=datetime.now(),
            level="INFO",
            agent_id="test-agent",
            name=name,
            attributes={}
        )
        
        assert event.event_category == expected_category, f"Failed for {name}, got {event.event_category} instead of {expected_category}"


def test_log_event_otel_naming():
    """Test that log_event properly maps legacy names to OpenTelemetry names."""
    # We'll test this by checking if the event name is properly mapped
    # when a legacy name is used
    # This test assumes that log_event correctly processes the event
    
    legacy_to_otel = {
        "LLM_call_start": "llm.request",
        "LLM_call_finish": "llm.response",
        "framework_patch": "framework.initialization",
        "model_request": "llm.chain.request",
        "model_response": "llm.chain.response"
    }
    
    for legacy_name, otel_name in legacy_to_otel.items():
        # In a real test, we'd check the actual logged event
        # Here we're just verifying the mapping logic by checking the mapping dictionary
        from cylestio_monitor.events.processing.logger import EVENT_NAME_MAPPING
        assert EVENT_NAME_MAPPING.get(legacy_name) == otel_name


def test_attributes_structure():
    """Test that complex nested data is correctly structured in attributes."""
    # Example of complex data that should be structured properly
    model_data = {
        "name": "claude-3-haiku-20240307",
        "provider": "anthropic",
        "parameters": {
            "temperature": 0.7,
            "max_tokens": 1000
        }
    }
    
    # Create event with nested data
    event = StandardizedEvent(
        timestamp=datetime.now(),
        level="INFO",
        agent_id="test-agent",
        name="llm.request",
        attributes={},
        model=model_data  # This should be moved into attributes with llm. prefix
    )
    
    result = event.to_dict()
    
    # Check that model data is correctly structured in attributes
    assert "llm.name" in result["attributes"] or "llm.provider" in result["attributes"]
    
    # Complex nested objects should be preserved but under the correct namespace
    if "llm.parameters" in result["attributes"]:
        assert isinstance(result["attributes"]["llm.parameters"], dict)
    elif "llm.parameters.temperature" in result["attributes"]:
        # Or they might be flattened with proper namespacing
        assert "llm.parameters.temperature" in result["attributes"]
        assert "llm.parameters.max_tokens" in result["attributes"] 